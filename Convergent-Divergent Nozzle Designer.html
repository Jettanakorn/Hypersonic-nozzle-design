// DOM Elements
const calculateBtn = document.getElementById('calculateBtn');
const resetBtn = document.getElementById('resetBtn');
const exportCSV = document.getElementById('exportCSV');
const exportPNG = document.getElementById('exportPNG');
const tabs = document.querySelectorAll('.tab');

// Initialize Chart
const ctx = document.getElementById('nozzleChart').getContext('2d');
let nozzleChart;

// Initialize with default values
resetToDefaults();

// Event Listeners
calculateBtn.addEventListener('click', calculateNozzle);
resetBtn.addEventListener('click', resetToDefaults);
exportCSV.addEventListener('click', exportContourData);
exportPNG.addEventListener('click', exportAsImage);

tabs.forEach(tab => {
    tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        const tabId = tab.getAttribute('data-tab');
        document.getElementById(`${tabId}-content`).classList.add('active');
    });
});

// Functions
function resetToDefaults() {
    document.getElementById('p1').value = '2000000';
    document.getElementById('T1').value = '3500';
    document.getElementById('FT').value = '10000';
    document.getElementById('m_dot').value = '0';
    document.getElementById('ALT').value = '10000';
    document.getElementById('g').value = '1.2';
    document.getElementById('R').value = '355';
    document.getElementById('TR').value = '10';

    // Clear results
    document.getElementById('meValue').textContent = '-';
    document.getElementById('veValue').textContent = '-';
    document.getElementById('mdotValue').textContent = '-';
    document.getElementById('ftValue').textContent = '-';
    document.getElementById('p0Value').textContent = '-';
    document.getElementById('t0Value').textContent = '-';
    document.getElementById('prValue').textContent = '-';
    document.getElementById('teValue').textContent = '-';

    // Clear chart if exists
    if (nozzleChart) {
        nozzleChart.destroy();
    }

    // Clear data table
    document.getElementById('contourData').innerHTML = '<tr><td colspan="3" style="text-align:center">No data available. Run calculation first.</td></tr>';

    showNotification('Form has been reset to default values', 'success');
}

function calculateNozzle() {
    // Get input values
    const p1 = parseFloat(document.getElementById('p1').value);
    const T1 = parseFloat(document.getElementById('T1').value);
    let FT = parseFloat(document.getElementById('FT').value);
    let m_dot = parseFloat(document.getElementById('m_dot').value);
    const ALT = parseFloat(document.getElementById('ALT').value);
    const g = parseFloat(document.getElementById('g').value);
    const R = parseFloat(document.getElementById('R').value);
    const TR = parseFloat(document.getElementById('TR').value) / 100; // Convert cm to m

    // Validate inputs
    if ([p1, T1, ALT, g, R, TR].some(isNaN)) {
        showNotification('Please enter valid numbers for all parameters', 'error');
        return;
    }

    if (FT === 0 && m_dot === 0) {
        showNotification('You must specify either thrust or mass flow rate', 'error');
        return;
    }

    // Calculate atmospheric conditions
    let T_amb, p_o;
    if (ALT > 11000 && ALT < 25000) {
        T_amb = -56.46;
        p_o = 1000 * (22.65 * Math.exp(1.73 - 0.000157 * ALT));
    } else if (ALT >= 25000) {
        T_amb = -131.21 + 0.00299 * ALT;
        p_o = 1000 * (2.488 * Math.pow((T_amb + 273.1) / 216.6, -11.388));
    } else {
        T_amb = 15.04 - 0.00649 * ALT;
        p_o = 1000 * (101.29 * Math.pow((T_amb + 273.1) / 288.08, 5.256));
    }

    // Calculate throat conditions
    const p_t = p1 * Math.pow(2 / (g + 1), g / (g - 1));
    const T_t = T1 * (2 / (g + 1));
    const rho_t = p_t / (R * T_t);
    const a_t = Math.sqrt(g * R * T_t);
    const A_t = Math.PI * TR * TR;

    // Calculate mass flow rate or thrust
    if (m_dot === 0) {
        const v_e = Math.sqrt((2 * g * R * T1) / (g - 1) * (1 - Math.pow(p_o / p1, (g - 1) / g)));
        m_dot = FT / (v_e + (p_t - p_o) * A_t / m_dot);
    } else if (FT === 0) {
        const v_e = Math.sqrt((2 * g * R * T1) / (g - 1) * (1 - Math.pow(p_o / p1, (g - 1) / g)));
        FT = m_dot * v_e + (p_t - p_o) * A_t;
    }

    // Calculate exit conditions
    const PR = p_o / p1;
    const T_e = T1 * Math.pow(PR, (g - 1) / g);
    const a_e = Math.sqrt(g * R * T_e);
    const v_e = Math.sqrt((2 * g * R * T1) / (g - 1) * (1 - Math.pow(PR, (g - 1) / g)));
    const Me = v_e / a_e;

    // Display results
    document.getElementById('meValue').textContent = Me.toFixed(2);
    document.getElementById('veValue').textContent = Math.round(v_e);
    document.getElementById('mdotValue').textContent = m_dot.toFixed(3);
    document.getElementById('ftValue').textContent = Math.round(FT);
    document.getElementById('p0Value').textContent = Math.round(p_o);
    document.getElementById('t0Value').textContent = '0Value.toFixed(2);
    document.getElementById('prValue').textContent = PR.toFixed(6);
    document.getElementById('teValue').textContent = Math.round(T_e);

    // Generate nozzle contour
    const contourData = generateNozzleContour(Me, g, T1, p1, p_o, R, TR, m_dot);

    // Update data table
    updateContourTable(contourData);

    // Plot nozzle
    plotNozzle(contourData);

    showNotification('Nozzle design completed successfully!', 'success');
}

function generateNozzleContour(Me, g, T1, p1, p_o, R, TR, m_dot) {
    const RTOD = 180 / Math.PI;
    const DTOR = Math.PI / 180;
    const points = [];

    // Prandtl-Meyer function
    const PM = (M) => {
        const A = Math.sqrt((g + 1) / (g - 1));
        const B = (g - 1) / (g + 1);
        return A * Math.atan(Math.sqrt(B * (M * M - 1))) - Math.atan(Math.sqrt(M * M - 1));
    };

    // Convergent section
    const convergentAngle = 30 * DTOR; // 30Â° half-angle
    const A_t = Math.PI * TR * TR;
    const p_t = p1 * Math.pow(2 / (g + 1), g / (g - 1));
    const T_t = T1 * (2 / (g + 1));
    const rho_t = p_t / (R * T_t);
    const v_t = Math.sqrt(g * R * T_t);
    const A_c = m_dot / (rho_t * v_t * 0.2)); // Approximate chamber area (Mach 0.2 at chamber)
    const R_c = Math.sqrt(A_c / Math.PI);

    // Convergent section points (assume linear taper)
    const L_con = (R_c - TR) / Math.tan(convergentAngle);
    const n_con = 10; // Number of points in convergent section
    for (let i = 0; i <= n_con; i++) {
        const t = i / n_con;
        const x = -L_con * (1 - t);
        const y = TR + (R_c - TR) * (1 - t);
        points.push({ x: x * 100, y: y * 100 }); // Convert m to cm
    }

    // Throat point
    points.push({ x: 0, y: TR * 100 });

    // Divergent section (Method of Characteristics)
    const v_max = PM(Me);
    const theta_max = v_max / 2; // Max turning angle
    const n_div = 60; // Number of points in divergent section
    let x = 0, y = TR;
    let theta = 0, nu = 0;
    const delta_theta = theta_max / n_div;

    for (let i = 1; i <= n_div; i++) {
        // Simplified MOC: assume linear increase in flow angle
        theta += delta_theta;
        nu = theta; // Ideal expansion
        const M_local = solveMachFromPM(nu, g, PM);
        const mu = Math.asin(1 / M_local);
        const dx = 0.01; // Small axial step (m)
        x += dx / Math.cos(theta);
        y += dx * Math.tan(theta);
        points.push({ x: x * 100, y: y * 100 }); // Convert m to cm
    });

    return points;
}

function solveMachFromPM(nu) {
    target, g, PM, tolerance = 1e-6) {
    // Numerical solver for Mach number given Prandtl-Meyer angle
    let M_low = 1, M_high = 100;
    let M_mid;
    while (M_high - M_low > tolerance) {
        M_mid = (M_low + M_low + M_high) / 2;
        const nu_calc = PM(M_mid);
        if (nu_calc < target) {
            M_low = M_mid;
        } else {
            M_high = M_mid;
        }
    }
    return M_mid;
}

function updateContourTable(contourData) {
    const tableBody = document.getElementById('contourData');
    tableBody.innerHTML = '';

    contourData.forEach((point, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <tr>
            <td>${index + 1}</td>
            <td>${point.x.toFixed(2)}</td>
            <td>${point.y.toFixed(2)}</td>
        `;
        tableBody.appendChild(row);
    });
}

function plotNozzle(contourData) {
    // Destroy existing chart
    if (nozzleChart) {
        nozzleChart.destroy();
    }

    // Extract x and y coordinates
    const xValues = contourData.map(p => p.x);
    const yValues = contourData.map(p => p.y);

    // Create symmetric lower contour
    const yValuesLower = yValues.map(y => -y);

    // Create chart
    nozzleChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: xValues,
            datasets: [
                {
                    label: 'Upper Contour',
                    data: yValues,
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                },
                {
                    label: 'Lower Contour',
                    data: yValuesLower,
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Axial Distance (cm)'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Radial Distance (cm)'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                    text: 'Convergent-Divergent Nozzle Contour'
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: (${context.parsed.x.toFixed(2)}, ${Math.abs(context.parsed.y).toFixed(2)}) cm`;
                        }
                    }
                }
            }
        }
    });
}

function exportContourData() {
    const contourData = [];

    // Get contour data from table
    const rows = document.querySelectorAll('#contourData tr');
    if (rows.length === 0 || rows[0].textContent.includes('No data')) {
        showNotification('No contour data to export', 'error');
        return;
    }

    // Create CSV content
    let csvContent = "Point,X (cm),Y (cm)\n";

    rows.forEach((row, index) => {
        const cells = row.querySelectorAll('td');
        const point = {
            id: parseInt(cells[0].textContent),
            x: parseFloat(cells[1].textContent),
            y: parseFloat(cells[2].textContent)
        };
        contourData.push(point);
        csvContent += `${point.id},${point.x.toFixed(2)},${point.y.toFixed(2)}\n`;
    });

    // Create download link
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', url);
    link.setAttribute('download', 'nozzle_contour.csv');
    link.style.visibility = 'hidden';
    document.body.appendChild(link');
    link.click();
    document.body.removeChild(link);
    
    showNotification('Contour data exported as CSV', 'success');
}

function exportAsImage() {
    if (!nozzleChart) {
        showNotification('No chart to export', 'error');
        return;
    }

    const image = nozzleChart.toBase64Image();
    const link = document.createElement('a');
    link.href = image;
    link.download = 'nozzle_contour.png';
    document.body.appendChild(link');
    link.click();
    document.body.removeChild(link);
    
    showNotification('Nozzle contour exported as PNG', 'success');
}

function showNotification(message, type) {
    const notification = document.getElementById('notification');
    notification.textContent = message;
    notification.className = `notification ${type} show`;
    
    setTimeout(() => {
        notification.classList.remove('show');
    }, 3000);
}
